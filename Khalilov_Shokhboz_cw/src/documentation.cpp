#include "documentation.h"

Documentation::Documentation(QWidget *parent) :QDialog(parent) {

    QString Documentation;
    close = new QPushButton("&close", this);
    grid_layout = new QGridLayout();
    ScrolArea = new QScrollArea(this);

    info = new QTextBrowser(ScrolArea);
    info->setText(Documentation);
    grid_layout->addWidget(info, 0, 0, 1, 1);
    grid_layout->addWidget(close, 1, 0, 1, 1, Qt::AlignRight);
    setLayout(grid_layout);
    info->setAlignment(Qt::AlignCenter);
    QString style_buttom = "QPushButton{ "
                           "background-color: #00bdaa;"
                           "height: 40px;"
                           "width: 100px;"
                           "margin:0;"
                           "border-radius: 0;"
                       "}"
                       "QPushButton:hover { "
                           "background-color: rgb(255, 69, 0);"
                        "}";

    close->setStyleSheet(style_buttom);
    setFixedSize(800, 800);
    connect(close, SIGNAL(clicked()), this, SLOT(close()));
    setWindowTitle("Documentation");
    setLayout(grid_layout);
    setStyleSheet("QTextBrowser{"
                  "font-size: 14pt;"
                  "}");
    info->setHtml(
"                <h1>Красно-чёрное дерево</h1>"
"                <p>двоичное дерево поиска, в котором каждый узел имеет атрибут цвета. При этом:</p>"
"                <ol>"
"                <li>"
"                  Узел может быть либо красным, либо чёрным и имеет двух потомков;  "
"                </li>"
"                <li>"
"                  Корень — как правило чёрный. Это правило слабо влияет на работоспособность модели, так как цвет корня всегда можно изменить с красного на чёрный;"
"                </li>"
"                <li>Все листья, не содержащие данных — чёрные.</li>"
"                <li>"
"                  Оба потомка каждого красного узла — чёрные."
"                </li>"
"                <li>"
"                Любой простой путь от узла-предка до листового узла-потомка содержит одинаковое число чёрных узлов.  "
"                </li>"
"                </ol>"
"                <p>"
"                Благодаря этим ограничениям, путь от корня до самого дальнего листа не более чем вдвое длиннее, чем до самого ближнего и дерево примерно сбалансировано. Операции вставки, удаления и поиска требуют в худшем случае времени, пропорционального длине дерева, что позволяет красно-чёрным деревьям быть более эффективными в худшем случае, чем обычные двоичные деревья поиска.</p>"
"                <p>Чтобы понять, как это работает, достаточно рассмотреть эффект свойств 4 и 5 вместе. Пусть для красно-чёрного дерева T число чёрных узлов от корня до листа равно B. Тогда кратчайший возможный путь до любого листа содержит B узлов и все они чёрные. Более длинный возможный путь может быть построен путём включения красных узлов. Однако, благодаря п.4 в дереве не может быть двух красных узлов подряд, а согласно пп. 2 и 3, путь начинается и кончается чёрным узлом. Поэтому самый длинный возможный путь состоит из 2H-1 узлов, попеременно красных и чёрных.</p>"
"                </p>"
"                <h1> Вставка </h1>"
"                <p > Новый узел в красно-чёрное дерево добавляется на место одного из листьев, окрашивается в красный цвет и к нему прикрепляется два листа (так как листья являются абстракцией, не содержащей данных, их добавление не требует дополнительной операции). Что происходит дальше, зависит от цвета близлежащих узлов. Заметим, что:</p>"
"                <ul>"
"                <li><b>Свойство 3</b> (Все листья чёрные) выполняется всегда.</li>"
"                <li><b>Свойство 4</b> (Оба потомка любого красного узла — чёрные) может нарушиться только при добавлении красного узла, при перекрашивании чёрного узла в красный или при повороте.</li>"
"                <li><b>Свойство 5</b> (Все пути от любого узла до листовых узлов содержат одинаковое число чёрных узлов) может нарушиться только при добавлении чёрного узла, перекрашивании красного узла в чёрный (или наоборот), или при повороте.</li>"
"                </ul>"
"                <h3> Случай 1:</h3>"
"                <p> Текущий узел в корне дерева. В этом случае, он перекрашивается в чёрный цвет, чтобы оставить верным Свойство 2 (Корень — чёрный). Так как это действие добавляет один чёрный узел в каждый путь, Свойство 5 (Все пути от любого данного узла до листовых узлов содержат одинаковое число чёрных узлов) не нарушается."
"                </p>"
"                <h3> Случай 2:</h3>"
"                <p>"
"                Предок текущего узла чёрный, то есть Свойство 4 (Оба потомка каждого красного узла — чёрные) не нарушается. В этом случае дерево остаётся корректным. Свойство 5 (Все пути от любого данного узла до листовых узлов содержат одинаковое число чёрных узлов) не нарушается, потому что текущий узел имеет двух чёрных листовых потомков, но так как N является красным, путь до каждого из этих потомков содержит такое же число чёрных узлов, что и путь до чёрного листа, который был заменен текущим узлом, так что свойство остается верным."
"                </p>"
"                <h3> Случай 3:</h3>"
"                <p>"
"                Если и родитель, и дядя — красные, то они оба могут быть перекрашены в чёрный, и дедушка станет красным (для сохранения свойства 5 (Все пути от любого данного узла до листовых узлов содержат одинаковое число чёрных узлов)). Теперь у текущего красного узла чёрный родитель. Так как любой путь через родителя или дядю должен проходить через дедушку, число чёрных узлов в этих путях не изменится. Однако, дедушка теперь может нарушить свойства 2 (Корень — чёрный) или 4 (Оба потомка каждого красного узла — чёрные) (свойство 4 может быть нарушено, так как родитель может быть красным). Чтобы это исправить, вся процедура рекурсивно выполняется на из случая 1."
"                </p>"

"                <h3> Случай 4:</h3>"
                "<p>"
                "Родитель является красным, но дядя — чёрный. Также, текущий узел — правый потомок, а в свою очередь — левый потомок своего предка. В этом случае может быть произведен поворот дерева, который меняет роли текущего узла и его предка. Тогда, для бывшего родительского узла в обновленной структуре используем случай 5, потому что Свойство 4 (Оба потомка любого красного узла — чёрные) все ещё нарушено. Вращение приводит к тому, что некоторые пути (в поддереве, обозначенном «1» на схеме) проходят через узел, чего не было до этого. Это также приводит к тому, что некоторые пути (в поддереве, обозначенном «3») не проходят через узел. Однако, оба эти узла являются красными, так что Свойство 5 (Все пути от любого данного узла до листовых узлов содержат одинаковое число чёрных узлов) не нарушается при вращении. Однако Свойство 4 всё ещё нарушается, но теперь задача сводится к Случаю 5."
                "</p>"
                "<h3> Случай 5:</h3>"
                "<p>"
"                    Родитель является красным, но дядя — чёрный, текущий узел — левый потомок и родитель — левый потомок. В этом случае выполняется поворот дерева на дедушки. В результате получается дерево, в котором бывший родитель теперь является родителем и текущего узла и бывшего дедушки. Известно, что дедушка — чёрный, так как его бывший потомок не мог бы в противном случае быть красным (без нарушения Свойства 4). Тогда цвета родитель и дедушка меняются и в результате дерево удовлетворяет Свойству 4 (Оба потомка любого красного узла — чёрные). Свойство 5 (Все пути от любого данного узла до листовых узлов содержат одинаковое число чёрных узлов) также остается верным, так как все пути, которые проходят через любой из этих трех узлов, ранее проходили через дедушки, поэтому теперь они все проходят через родителя. В каждом случае, из этих трёх узлов только один окрашен в чёрный."
"                    </p>"
    "<h3>Повернуть влево</h3>"
    "<p>При вращении влево расположение узлов справа преобразуется в расположение узлов слева.</p>"
    "<h4>Алгоритм</h4>"
    "<ol>"
    "   <li>"
    "       <font style=\"vertical-align: inherit;\">"
    "           Пусть исходное дерево будет:"
    "       </font>"
            "<br>"
    "       <figure>"
    "          <img src =\":/img/res/tree_l1.png\">"
    "       </figure>"
    "   </li>"
    "   <li>"
    "       <font style=\"vertical-align: inherit;\">"
    "           Если y имеет левое поддерево, назначьте \"x\" в качестве родителя левого поддерева \"y\"."
    "       </font>"
    "       <br>"
    "       <figure>"
    "           <img src =\":/img/res/tree_l2.png\">"
    "       </figure>"
    "   </li>"
    "   <li>"
    "       <font style=\"vertical-align: inherit;\">"
    "           Если родитель \"x\" есть NULL, сделатьy как корень дерева."
    "       </font>"
    "       <br>"
    "   </li>"
    "   <li>"
    "      <font style=\"vertical-align: inherit;\">"
    "           Иначе, если \"x\" левый ребенок \"p\", сделать \"y\" как левый ребенок \"p\"."
    "      </font>"
    "       <br>"
    "   </li>"
    "   <li>"
    "       <font style=\"vertical-align: inherit;\">"
    "           Иначе назначить \"y\" как правильный ребенок \"p\""
    "       </font>"
    "       <br>"
    "       <figure>"
    "          <img src =\":/img/res/tree_l3.png\">"
    "       </figure>"
    "   </li>"
    "   <li>"
    "       <font style=\"vertical-align: inherit;\">"
    "           Сделать \"y\" как родитель \"x\""
    "       </font>"
    "       <br>"
    "       <figure>"
    "          <img src =\":/img/res/tree_l4.png\">"
    "       </figure>"
    "   </li>"
    "</ol>"
    ""
    "<h3>Повернуть влево</h3>"
    "<p>При вращении влево расположение узлов справа преобразуется в расположение узлов слева.</p>"
    "<h4>Алгоритм</h4>"
    "<ol>"
    "   <li>"
    "       <font style=\"vertical-align: inherit;\">"
    "           Пусть исходное дерево будет:"
    "       </font>"
    "       <br>"
    "       <figure>"
    "          <img src =\":/img/res/tree_r1.png\">"
    "       </figure>"
    "   </li>"
    "   <li>"
    "      <font style=\"vertical-align: inherit;\">"
    "         Если \"x\" имеет правое поддерево, назначьте y в качестве родителя правого поддерева \"x\""
    "      </font>"
    "       <br>"
    "      <figure>"
    "          <img src =\":/img/res/tree_r2.png\">"
    "      </figure>"
    "   </li>"
    "   <li>"
    "       <font style=\"vertical-align: inherit;\">"
    "           Если родитель \"y\" есть NULL, сделать \"x\" как корень дерева."
    "       </font>"
    "       <br>"
    "   </li>"
    "   <li>"
    "       <font style=\"vertical-align: inherit;\">"
    "           Иначе, если \"y\" правый дочерний элемент своего родителя \"p\", сделать \"x\" как правильный ребенок \"p\""
    "       </font>"
    "       <br>"
    "   </li>"
    "   <li>"
    "       <font style=\"vertical-align: inherit;\">"
    "           Иначе назначить \"x\" как левый ребенок \"p\""
    "       </font>"
    "       <br>"
    "       <figure>"
    "          <img src =\":/img/res/tree_r3.png\">"
    "       </figure>"
    "   </li>"
    "   <li>"
    "      <font style=\"vertical-align: inherit;\">"
    "          Сделать \"x\" как родитель \"y\""
    "      </font>"
    "       <br>"
    "      <figure>"
    "         <img src =\":/img/res/tree_r4.png\">"
    "      </figure>"
    "   </li>"
    "</ol>"

                );

}

Documentation::~Documentation() {

    delete close;
    delete grid_layout;
    delete info;
}
